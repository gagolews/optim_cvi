# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' @export
.CVI_create <- function(type, X, K, allow_undo = TRUE) {
    .Call(`_CVI__CVI_create`, type, X, K, allow_undo)
}

#' @export
.CVI_set_labels <- function(cvi_ptr, y) {
    invisible(.Call(`_CVI__CVI_set_labels`, cvi_ptr, y))
}

#' @export
.CVI_compute <- function(cvi_ptr) {
    .Call(`_CVI__CVI_compute`, cvi_ptr)
}

#' @export
.CVI_undo <- function(cvi_ptr) {
    invisible(.Call(`_CVI__CVI_undo`, cvi_ptr))
}

#' @export
.CVI_modify <- function(cvi_ptr, i, j) {
    invisible(.Call(`_CVI__CVI_modify`, cvi_ptr, i, j))
}

#' @title The Calinski-Harabasz Cluster Validity Index (Variance Ratio Criterion)
#'
#' TODO: update this docstring
#'
#' @references
#' T. Calinski & J. Harabasz. A dendrite method for cluster analysis,
#' Communications in Statistics, 3(1), 1974, pp. 1-27,
#' doi:10.1080/03610927408827101.
#'
#' @param X data matrix of size n*d
#' @param y vector of n integer labels in [1, K], where `y[i]`
#'          is the cluster id of the i-th point, `X[i,]`
#' @param K number of clusters, `max(y)`
#'
#' @return The computed index.
#' @export
CVI_CalinskiHarabasz <- function(X, y, K) {
    .Call(`_CVI_CVI_CalinskiHarabasz`, X, y, K)
}

#' @title Negated Within-Cluster Sum of Squares
#'
#' TODO: update this docstring
#'
#' Objective function used, amongst others, in the k-means and
#' the Ward and CaliÅ„ski&Harabasz algorithms.
#'
#'
#' @param X data matrix of size n*d
#' @param y vector of n integer labels in [1, K], where `y[i]`
#'          is the cluster id of the i-th point, `X[i,]`
#' @param K number of clusters, `max(y)`
#'
#' @return The computed index.
#' @export
CVI_WCSS <- function(X, y, K) {
    .Call(`_CVI_CVI_WCSS`, X, y, K)
}

#' @title Negated Ball-Hall Index
#'
#' TODO: update this docstring
#'
#' Within cluster sum of squares weighted by the cluster cardinality
#'
#'
#' @param X data matrix of size n*d
#' @param y vector of n integer labels in [1, K], where `y[i]`
#'          is the cluster id of the i-th point, `X[i,]`
#' @param K number of clusters, `max(y)`
#'
#' @return The computed index.
#' @export
CVI_BallHall <- function(X, y, K) {
    .Call(`_CVI_CVI_BallHall`, X, y, K)
}

#' @title The Baker-Hubert Gamma Coefficient
#'
#' TODO: update this docstring
#'
#' Equal to the Goodman-Kruskal rank correlation measure
#' between the vector of all pairwise distances and the 0/1 indicator
#' function stating whether the corresponding pair of points belongs
#' to the same cluster (0) or not (1).
#'
#' Gives a value between -1 and 1. (NC-ND)/(NC+ND),
#' where NC - number of concordant and ND - number of discordant pairs.
#'
#' F.B. Baker, L.J. Hubert, Measuring the power of hierarchical cluster
#' analysis, Journal of the American Statistical Association 70(349), 1975,
#' pp. 31-38.
#'
#'
#' @param X data matrix of size n*d
#' @param y vector of n integer labels in [1, K], where `y[i]`
#'          is the cluster id of the i-th point, `X[i,]`
#' @param K number of clusters, `max(y)`
#'
#' @return The computed index.
#' @export
CVI_Gamma <- function(X, y, K) {
    .Call(`_CVI_CVI_Gamma`, X, y, K)
}

#' @title The Negated Davies-Bouldin Cluster Validity Index
#'
#' TODO: update this docstring
#'
#' @references
#' D.L. Davies, D.W. Bouldin,
#' A Cluster Separation Measure,
#' IEEE Transactions on Pattern Analysis and Machine Intelligence. PAMI-1 (2),
#' 1979, pp. 224-227, doi:10.1109/TPAMI.1979.4766909
#'
#' @param X data matrix of size n*d
#' @param y vector of n integer labels in [1, K], where `y[i]`
#'          is the cluster id of the i-th point, `X[i,]`
#' @param K number of clusters, `max(y)`
#'
#' @return The computed index, which is the additive inverse (negation)
#'         of the original Davies-Bouldin score. Negation is for consistency
#'         with other indices -- the higher the score, the better.
#' @export
CVI_DaviesBouldin <- function(X, y, K) {
    .Call(`_CVI_CVI_DaviesBouldin`, X, y, K)
}

#' @title The Silhouette Coefficient
#'
#' TODO: update this docstring
#'
#' @references
#' P.J. Rousseeuw, Silhouettes: a Graphical Aid to the Interpretation and
#' Validation of Cluster Analysis, Computational and Applied Mathematics 20,
#' 1987, pp. 53-65, doi:10.1016/0377-0427(87)90125-7.
#'
#' @param X data matrix of size n*d
#' @param y vector of n integer labels in [1, K], where `y[i]`
#'          is the cluster id of the i-th point, `X[i,]`
#' @param K number of clusters, `max(y)`
#'
#' @return The computed index.
#'
#' @export
CVI_Silhouette <- function(X, y, K) {
    .Call(`_CVI_CVI_Silhouette`, X, y, K)
}

#' @title The Silhouette Coefficient
#'
#' TODO: update this docstring
#'
#' @references
#' P.J. Rousseeuw, Silhouettes: a Graphical Aid to the Interpretation and
#' Validation of Cluster Analysis, Computational and Applied Mathematics 20,
#' 1987, pp. 53-65, doi:10.1016/0377-0427(87)90125-7.
#'
#' @param X data matrix of size n*d
#' @param y vector of n integer labels in [1, K], where `y[i]`
#'          is the cluster id of the i-th point, `X[i,]`
#' @param K number of clusters, `max(y)`
#'
#' @return The computed index.
#'
#' @export
CVI_SilhouetteW <- function(X, y, K) {
    .Call(`_CVI_CVI_SilhouetteW`, X, y, K)
}

#' @title Dunn's index for measuring the degree to which clusters are compact separated
#'
#' TODO: update this docstring
#'
#' The index is defined by Eq.(3) in (Dunn, 1973).
#'
#' @references
#' J.C. Dunn, A Fuzzy Relative of the ISODATA Process and Its Use in Detecting
#' Compact Well-Separated Clusters, Journal of Cybernetics 3(3), 1973,
#' pp. 32-57, doi:10.1080/01969727308546046.
#'
#' @param X data matrix of size n*d
#' @param y vector of n integer labels in [1, K], where `y[i]`
#'          is the cluster id of the i-th point, `X[i,]`
#' @param K number of clusters, `max(y)`
#'
#' @return The computed index.
#'
#' @export
CVI_Dunn <- function(X, y, K) {
    .Call(`_CVI_CVI_Dunn`, X, y, K)
}

#' @title Generalised Dunn's index
#'
#' TODO: update this docstring
#'
#' @references
#' TODO: update
#'
#' @param X data matrix of size n*d
#' @param y vector of n integer labels in [1, K], where `y[i]`
#'          is the cluster id of the i-th point, `X[i,]`
#' @param K number of clusters, `max(y)`
#'
#' @return The computed index.
#'
#' @export
CVI_GDunn <- function(X, y, K, lowercaseDelta, uppercaseDelta) {
    .Call(`_CVI_CVI_GDunn`, X, y, K, lowercaseDelta, uppercaseDelta)
}

#' @title Within-Cluster Nearest-Neighbours
#'
#' TODO: update this docstring
#'
#' @param X data matrix of size n*d
#' @param y vector of n integer labels in [1, K], where `y[i]`
#'          is the cluster id of the i-th point, `X[i,]`
#' @param K number of clusters, `max(y)`
#' @param M number of nearest neighbours
#'
#' @return The computed index.
#'
#' @export
CVI_WCNN <- function(X, y, K, M = 10L) {
    .Call(`_CVI_CVI_WCNN`, X, y, K, M)
}

#' @title OWA-based Dunn-like Indices Based on Near Neighbours
#'
#' TODO: update this docstring
#'
#' @param X data matrix of size n*d
#' @param y vector of n integer labels in [1, K], where `y[i]`
#'          is the cluster id of the i-th point, `X[i,]`
#' @param K number of clusters, `max(y)`
#' @param M number of nearest neighbours
#'
#' @return The computed index.
#'
#' @export
CVI_DuNNOWA <- function(X, y, K, M = 10L, owa_numerator = "Min", owa_denominator = "Max") {
    .Call(`_CVI_CVI_DuNNOWA`, X, y, K, M, owa_numerator, owa_denominator)
}

#' (Tabu-like) (stochastic) hill climbing
#'
#' @param cvi_ptr pointer, see _CVI_create()
#' @param y0 initial label vector
#' @param allow_revisit should a `tabu` list be maintained?
#' @param max_iter_with_no_improvement how many iterations
#'        where there are no improvement in the fitness function
#'        before we give up?
#' @param max_iter maximal number of iterations
#' @param max_samples if <= 0, then an exhaustive search of all the
#'        neighbouring points is conveyed; otherwise, choose
#'        next candidates at random
#' @param verbose print additional info on the console?
#'
#' @return see optim()
#' @export
.CVI_improve <- function(cvi_ptr, y0, allow_revisit = FALSE, max_iter_with_no_improvement = 250L, max_iter = 10000L, max_samples = -1L, verbose = FALSE) {
    .Call(`_CVI__CVI_improve`, cvi_ptr, y0, allow_revisit, max_iter_with_no_improvement, max_iter, max_samples, verbose)
}

#' Tabu-like hill climbing from multiple initial points
#'
#' an exhaustive search of all the neighbouring points is conveyed
#'
#' @param cvi_ptr pointer, see _CVI_create()
#' @param Y0 set of initial label vectors
#' @param max_iter_with_no_improvement how many iterations
#'        where there are no improvement in the fitness function
#'        before we give up?
#' @param max_iter maximal number of iterations
#' @param verbose print additional info on the console?
#'
#' @return see optim()
#' @export
.CVI_improve_turbo <- function(cvi_ptr, Y0, max_iter_with_no_improvement = 250L, max_iter = 10000L, verbose = FALSE) {
    .Call(`_CVI__CVI_improve_turbo`, cvi_ptr, Y0, max_iter_with_no_improvement, max_iter, verbose)
}

